/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";var T=Object.defineProperty;var M=Object.getOwnPropertyDescriptor;var K=Object.getOwnPropertyNames;var L=Object.prototype.hasOwnProperty;var _=(r,t)=>{for(var e in t)T(r,e,{get:t[e],enumerable:!0})},j=(r,t,e,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of K(t))!L.call(r,s)&&s!==e&&T(r,s,{get:()=>t[s],enumerable:!(i=M(t,s))||i.enumerable});return r};var q=r=>j(T({},"__esModule",{value:!0}),r);var Q={};_(Q,{default:()=>$});module.exports=q(Q);var d=require("obsidian");function N(r){let t=new Date;return{...r,createdAt:t,updatedAt:t}}function B(r){return{...r,createdAt:r.createdAt.toISOString(),updatedAt:r.updatedAt.toISOString()}}function C(r){return{...r,createdAt:new Date(r.createdAt),updatedAt:new Date(r.updatedAt)}}function R(r){return[...r].sort((t,e)=>e.similarity-t.similarity)}function F(r,t){return r.slice(0,t)}async function b(r){let e=new TextEncoder().encode(r);try{let i=await crypto.subtle.digest("SHA-256",e);return`sha256:${Array.from(new Uint8Array(i)).map(o=>o.toString(16).padStart(2,"0")).join("")}`}catch(i){return`simple:${J(r)}`}}function J(r){let t=0;for(let e=0;e<r.length;e++){let i=r.charCodeAt(e);t=(t<<5)-t+i,t=t&t}return Math.abs(t).toString(16)}function f(r,t){return r===null||t===null?!1:r===t}var y=class{constructor(t,e,i){this.embeddingProvider=t;this.embeddingRepository=e;this.noteRepository=i}async execute(t,e){let i=e!=null?e:await this.noteRepository.findById(t);if(!i)throw new Error(`Note not found: ${t}`);let s=await b(i.content),n=await this.embeddingRepository.getContentHash(t);if(n&&f(n,s)){let l=await this.embeddingRepository.findById(t);if(l)return{embedding:l,wasUpdated:!1,reason:"skipped"}}let o=await this.embeddingProvider.embed(i.content),a=N({noteId:t,notePath:i.path,title:i.title,contentHash:s,vector:o,model:this.embeddingProvider.getModel(),provider:this.embeddingProvider.getProvider(),dimensions:this.embeddingProvider.getDimensions()});return await this.embeddingRepository.save(a),{embedding:a,wasUpdated:!0,reason:n?"stale":"new"}}async embedIfStale(t,e){let i=await this.embeddingRepository.getContentHash(t);return i&&f(i,e)?null:(await this.execute(t)).embedding}async forceEmbed(t){let e=await this.noteRepository.findById(t);if(!e)throw new Error(`Note not found: ${t}`);let i=await b(e.content),s=await this.embeddingProvider.embed(e.content),n=N({noteId:t,notePath:e.path,title:e.title,contentHash:i,vector:s,model:this.embeddingProvider.getModel(),provider:this.embeddingProvider.getProvider(),dimensions:this.embeddingProvider.getDimensions()});return await this.embeddingRepository.save(n),n}};var E=class{constructor(t,e){this.embeddingProvider=t;this.embeddingRepository=e}async execute(t,e){let{limit:i=10,threshold:s=.3,excludeNoteIds:n=[],excludeFolders:o=[]}=e||{},a=await this.embeddingProvider.embed(t),l=await this.embeddingRepository.findAll(),p=[];for(let u of l){if(n.includes(u.noteId)||o.some(I=>u.notePath.startsWith(I+"/")))continue;let h=this.cosineSimilarity(a,u.vector);h>=s&&p.push({noteId:u.noteId,notePath:u.notePath,title:u.title,similarity:h})}let A=R(p);return F(A,i)}async findSimilarToNote(t,e){let i=await this.embeddingRepository.findById(t);if(!i)throw new Error(`Embedding not found for note: ${t}`);let{limit:s=10,threshold:n=.3,excludeNoteIds:o=[],excludeFolders:a=[]}=e||{},l=[...o,t],p=await this.embeddingRepository.findAll(),A=[];for(let h of p){if(l.includes(h.noteId)||a.some(H=>h.notePath.startsWith(H+"/")))continue;let I=this.cosineSimilarity(i.vector,h.vector);I>=n&&A.push({noteId:h.noteId,notePath:h.notePath,title:h.title,similarity:I})}let u=R(A);return F(u,s)}cosineSimilarity(t,e){if(t.length!==e.length)throw new Error("Vector dimensions must match");let i=0,s=0,n=0;for(let a=0;a<t.length;a++)i+=t[a]*e[a],s+=t[a]*t[a],n+=e[a]*e[a];let o=Math.sqrt(s)*Math.sqrt(n);return o===0?0:i/o}};var v=class{constructor(t,e,i){this.embeddingProvider=t;this.embeddingRepository=e;this.noteRepository=i;this.embedNoteUseCase=new y(t,e,i),this.searchSimilarUseCase=new E(t,e)}isAvailable(){return this.embeddingProvider.isAvailable()}async embedNote(t){let e=await this.embedNoteUseCase.execute(t);return e.wasUpdated&&await this.embeddingRepository.updateIndexEntry(e.embedding),e}async embedNoteByPath(t){let e=await this.noteRepository.findByPath(t);if(!e)throw new Error(`Note not found at path: ${t}`);let i=await this.embedNoteUseCase.execute(e.noteId,e);return i.wasUpdated&&await this.embeddingRepository.updateIndexEntry(i.embedding),i}async embedAllNotes(t=[],e){let i=await this.noteRepository.findAllExcluding(t),s={total:i.length,completed:0,skipped:0,failed:0,currentNote:null};for(let n of i){s.currentNote=n.path,e==null||e(s);try{(await this.embedNoteUseCase.execute(n.noteId)).reason==="skipped"&&s.skipped++,s.completed++}catch(o){console.error(`Failed to embed ${n.path}:`,o),s.failed++}}return s.currentNote=null,e==null||e(s),await this.embeddingRepository.updateIndex(),{success:s.completed-s.skipped,skipped:s.skipped,failed:s.failed}}async embedStaleNotes(t=[],e){let i=await this.noteRepository.findAllExcluding(t),s={total:i.length,completed:0,skipped:0,failed:0,currentNote:null},n=0;for(let o of i){s.currentNote=o.path,e==null||e(s);try{let a=await b(o.content),l=await this.embeddingRepository.getContentHash(o.noteId);l&&f(l,a)?s.skipped++:(await this.embedNoteUseCase.execute(o.noteId),n++),s.completed++}catch(a){console.error(`Failed to embed ${o.path}:`,a),s.failed++}}return s.currentNote=null,e==null||e(s),await this.embeddingRepository.updateIndex(),{updated:n,skipped:s.skipped,failed:s.failed}}async searchSimilar(t,e){return this.searchSimilarUseCase.execute(t,e)}async findSimilarToNote(t,e){return this.searchSimilarUseCase.findSimilarToNote(t,e)}async getStats(){let t=await this.embeddingRepository.getIndex();return{totalEmbeddings:t.totalNotes,model:t.model||this.embeddingProvider.getModel(),provider:this.embeddingProvider.getProvider(),dimensions:t.dimensions||this.embeddingProvider.getDimensions(),lastUpdated:t.lastUpdated||null}}async deleteEmbedding(t){await this.embeddingRepository.delete(t),await this.embeddingRepository.updateIndex()}async clearAllEmbeddings(){await this.embeddingRepository.clear()}async hasEmbedding(t){return this.embeddingRepository.exists(t)}async getEmbedding(t){return this.embeddingRepository.findById(t)}};var D=require("obsidian"),U="https://api.openai.com/v1/embeddings",W="text-embedding-3-small",G=1536,w=class{constructor(t,e=W,i=G){this.apiKey=t;this.model=e,this.dimensions=i}async embed(t){return(await this.callOpenAI([t])).data[0].embedding}async embedBatch(t){let i=[];for(let s=0;s<t.length;s+=100){let n=t.slice(s,s+100),a=(await this.callOpenAI(n)).data.sort((l,p)=>l.index-p.index);i.push(...a.map(l=>l.embedding))}return i}isAvailable(){return!!this.apiKey&&this.apiKey.length>0}getModel(){return this.model}getProvider(){return"openai"}getDimensions(){return this.dimensions}async testApiKey(t){try{return(await(0,D.requestUrl)({url:U,method:"POST",headers:{Authorization:`Bearer ${t}`,"Content-Type":"application/json"},body:JSON.stringify({model:this.model,input:"test"})})).status===200}catch(e){return!1}}setApiKey(t){this.apiKey=t}async callOpenAI(t){if(!this.apiKey)throw new Error("OpenAI API key not configured");let e=t.map(i=>{let s=i.trim();return s.length>0?s:" "});try{let i=await(0,D.requestUrl)({url:U,method:"POST",headers:{Authorization:`Bearer ${this.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:this.model,input:e})});if(i.status!==200)throw new Error(`OpenAI API error: ${i.status}`);return i.json}catch(i){throw i instanceof Error?new Error(`OpenAI embedding failed: ${i.message}`):i}}};var c=require("obsidian");var O="1.0.0",Z={storagePath:"09_Embedded",embeddingsFolder:"embeddings"},P=class{constructor(t,e){this.app=t;this.indexCache=null;this.config={...Z,...e}}async initialize(){let t=(0,c.normalizePath)(this.config.storagePath),e=(0,c.normalizePath)(`${t}/${this.config.embeddingsFolder}`);await this.ensureFolder(t),await this.ensureFolder(e);let i=this.getIndexPath();await this.fileExists(i)||await this.saveIndex(this.createEmptyIndex())}async save(t){let e=this.getEmbeddingPath(t.noteId),i=B(t),s=JSON.stringify(i,null,2);await this.writeFile(e,s),this.invalidateIndexCache()}async saveBatch(t){for(let i=0;i<t.length;i+=10){let s=t.slice(i,i+10);await Promise.all(s.map(n=>this.save(n)))}}async findById(t){let e=this.getEmbeddingPath(t);if(!await this.fileExists(e))return null;try{let i=await this.readFile(e),s=JSON.parse(i);return C(s)}catch(i){return null}}async findByPath(t){let e=await this.getIndex();for(let[i,s]of Object.entries(e.notes))if(s.path===t)return this.findById(i);return null}async findAll(){let t=await this.getIndex(),e=[];for(let i of Object.keys(t.notes)){let s=await this.findById(i);s&&e.push(s)}return e}async delete(t){let e=this.getEmbeddingPath(t);await this.deleteFile(e),this.invalidateIndexCache()}async exists(t){let e=this.getEmbeddingPath(t);return this.fileExists(e)}async getContentHash(t){var i;return((i=(await this.getIndex()).notes[t])==null?void 0:i.contentHash)||null}async updateIndex(){let t=(0,c.normalizePath)(`${this.config.storagePath}/${this.config.embeddingsFolder}`),e=this.app.vault.getAbstractFileByPath(t);if(!(e instanceof c.TFolder)){await this.saveIndex(this.createEmptyIndex());return}let i={},s="",n=0;for(let a of e.children)if(a instanceof c.TFile&&a.extension==="json")try{let l=await this.app.vault.read(a),p=C(JSON.parse(l));i[p.noteId]={path:p.notePath,contentHash:p.contentHash,updatedAt:p.updatedAt.toISOString()},s||(s=p.model),n||(n=p.dimensions)}catch(l){}let o={version:O,totalNotes:Object.keys(i).length,lastUpdated:new Date().toISOString(),model:s,dimensions:n,notes:i};await this.saveIndex(o)}async updateIndexEntry(t){let e=await this.getIndex();e.notes[t.noteId]={path:t.notePath,contentHash:t.contentHash,updatedAt:t.updatedAt.toISOString()},e.totalNotes=Object.keys(e.notes).length,e.lastUpdated=new Date().toISOString(),e.model||(e.model=t.model),e.dimensions||(e.dimensions=t.dimensions),await this.saveIndex(e)}async getIndex(){if(this.indexCache)return this.indexCache;let t=this.getIndexPath();if(!await this.fileExists(t)){let e=this.createEmptyIndex();return this.indexCache=e,e}try{let e=await this.readFile(t),i=JSON.parse(e);return this.indexCache=i,i}catch(e){let i=this.createEmptyIndex();return this.indexCache=i,i}}async count(){return(await this.getIndex()).totalNotes}async clear(){let t=(0,c.normalizePath)(`${this.config.storagePath}/${this.config.embeddingsFolder}`),e=this.app.vault.getAbstractFileByPath(t);if(e instanceof c.TFolder)for(let i of e.children)i instanceof c.TFile&&await this.app.vault.delete(i);await this.saveIndex(this.createEmptyIndex())}getIndexPath(){return(0,c.normalizePath)(`${this.config.storagePath}/index.json`)}getEmbeddingPath(t){let e=t.replace(/[^a-zA-Z0-9-_]/g,"_");return(0,c.normalizePath)(`${this.config.storagePath}/${this.config.embeddingsFolder}/${e}.json`)}createEmptyIndex(){return{version:O,totalNotes:0,lastUpdated:new Date().toISOString(),model:"",dimensions:0,notes:{}}}async saveIndex(t){let e=this.getIndexPath(),i=JSON.stringify(t,null,2);await this.writeFile(e,i),this.indexCache=t}invalidateIndexCache(){this.indexCache=null}async ensureFolder(t){let e=this.app.vault.getAbstractFileByPath(t);if(!(e instanceof c.TFolder)){if(e instanceof c.TFile)throw new Error(`Path exists as file, expected folder: ${t}`);try{await this.app.vault.createFolder(t)}catch(i){let s=i instanceof Error?i.message:String(i);if(s.toLowerCase().includes("already exists")||s.toLowerCase().includes("folder already exists")){console.log(`Vault Embeddings: Folder already exists (sync OK): ${t}`);return}if(await this.delay(100),this.app.vault.getAbstractFileByPath(t)instanceof c.TFolder){console.log(`Vault Embeddings: Folder exists after retry: ${t}`);return}throw new Error(`Failed to create folder: ${t} - ${s}`)}}}delay(t){return new Promise(e=>setTimeout(e,t))}async fileExists(t){if(this.app.vault.getAbstractFileByPath(t)instanceof c.TFile)return!0;try{return await this.app.vault.adapter.exists(t)}catch(i){return!1}}async readFile(t){let e=this.app.vault.getAbstractFileByPath(t);if(e instanceof c.TFile)return this.app.vault.read(e);try{let i=await this.app.vault.adapter.read(t);return console.log(`Vault Embeddings: Used adapter.read for: ${t}`),i}catch(i){throw new Error(`File not found: ${t}`)}}async writeFile(t,e){let i=this.app.vault.getAbstractFileByPath(t);if(i instanceof c.TFile){await this.app.vault.modify(i,e);return}try{await this.app.vault.create(t,e)}catch(s){let n=s instanceof Error?s.message:String(s);if(n.toLowerCase().includes("already exists")||n.toLowerCase().includes("file already exists")){console.log(`Vault Embeddings: File already exists, retrying with modify: ${t}`),await this.delay(100);let o=this.app.vault.getAbstractFileByPath(t);if(o instanceof c.TFile){await this.app.vault.modify(o,e);return}await this.app.vault.adapter.write(t,e),console.log(`Vault Embeddings: Used adapter.write for: ${t}`);return}throw s}}async deleteFile(t){let e=this.app.vault.getAbstractFileByPath(t);e instanceof c.TFile&&await this.app.vault.delete(e)}};var g=require("obsidian"),x=class{constructor(t){this.app=t}async findById(t){let e=this.app.vault.getMarkdownFiles();for(let i of e)if(this.generateNoteId(i.path)===t)return this.fileToNoteContent(i);return null}async findByPath(t){let e=(0,g.normalizePath)(t),i=this.app.vault.getAbstractFileByPath(e);return i instanceof g.TFile?this.fileToNoteContent(i):null}async findAllMarkdownNotes(){let t=this.app.vault.getMarkdownFiles(),e=[];for(let i of t){let s=await this.fileToNoteContent(i);s&&e.push(s)}return e}async findByFolder(t){let e=this.app.vault.getMarkdownFiles(),i=[],s=(0,g.normalizePath)(t);for(let n of e)if((0,g.normalizePath)(n.path).startsWith(s+"/")){let a=await this.fileToNoteContent(n);a&&i.push(a)}return i}async findAllExcluding(t){let e=this.app.vault.getMarkdownFiles(),i=[],s=t.map(n=>(0,g.normalizePath)(n));for(let n of e){let o=(0,g.normalizePath)(n.path);if(!s.some(l=>o.startsWith(l+"/")||o===l)){let l=await this.fileToNoteContent(n);l&&i.push(l)}}return i}async exists(t){return await this.findById(t)!==null}generateNoteId(t){let i=(0,g.normalizePath)(t).replace(/\.md$/,"");return this.simpleHash(i)}async fileToNoteContent(t){try{let e=await this.app.vault.cachedRead(t),i=(0,g.normalizePath)(t.path);return{noteId:this.generateNoteId(t.path),path:i,title:t.basename,content:e,modifiedAt:new Date(t.stat.mtime)}}catch(e){return null}}simpleHash(t){let e=0;for(let i=0;i<t.length;i++){let s=t.charCodeAt(i);e=(e<<5)-e+s,e=e&e}return Math.abs(e).toString(16).padStart(8,"0")}};var z={openaiApiKey:"",storagePath:"09_Embedded",excludedFolders:["06_Meta","Templates"],autoEmbed:!0,autoEmbedDelay:5e3,model:"text-embedding-3-small"};var m=require("obsidian");var V=require("obsidian"),S=class extends V.Modal{constructor(e,i){super(e);this.progressEl=null;this.progressFillEl=null;this.progressStatusEl=null;this.progressPercentEl=null;this.closeBtn=null;this.modalTitle=i}onOpen(){let{contentEl:e}=this;e.empty(),e.addClass("vault-embeddings-progress-modal"),e.createEl("h2",{text:this.modalTitle}),this.progressEl=e.createDiv({cls:"progress-section"}),this.createProgressUI();let i=e.createDiv({cls:"progress-buttons"});i.style.marginTop="20px",i.style.textAlign="center",this.closeBtn=i.createEl("button",{text:"Close"}),this.closeBtn.disabled=!0,this.closeBtn.addEventListener("click",()=>this.close())}createProgressUI(){if(!this.progressEl)return;this.progressEl.empty();let e=this.progressEl.createDiv({cls:"progress-container"});e.style.marginTop="15px",this.progressStatusEl=e.createEl("p",{text:"Preparing..."}),this.progressStatusEl.style.marginBottom="10px";let i=e.createDiv({cls:"progress-bar"});i.style.width="100%",i.style.height="20px",i.style.backgroundColor="var(--background-modifier-border)",i.style.borderRadius="10px",i.style.overflow="hidden",i.style.position="relative",this.progressFillEl=i.createDiv({cls:"progress-fill"}),this.progressFillEl.setCssStyles({width:"0%",height:"100%",backgroundColor:"var(--interactive-accent)",transition:"width 0.3s ease",position:"absolute",left:"0",top:"0"}),this.progressPercentEl=e.createEl("p",{text:"0%"}),this.progressPercentEl.style.textAlign="center",this.progressPercentEl.style.marginTop="10px"}updateProgress(e){this.progressFillEl&&this.progressFillEl.setCssStyles({width:`${e.percentage}%`}),this.progressStatusEl&&(this.progressStatusEl.textContent=e.message),this.progressPercentEl&&(this.progressPercentEl.textContent=`${e.current} / ${e.total} (${e.percentage}%)`)}setComplete(e){this.progressStatusEl&&(this.progressStatusEl.textContent=e),this.progressFillEl&&this.progressFillEl.setCssStyles({width:"100%",backgroundColor:"var(--interactive-success)"}),this.progressPercentEl&&(this.progressPercentEl.textContent="100%"),this.closeBtn&&(this.closeBtn.disabled=!1,this.closeBtn.focus())}setError(e){this.progressStatusEl&&(this.progressStatusEl.textContent=e,this.progressStatusEl.style.color="var(--text-error)"),this.progressFillEl&&this.progressFillEl.setCssStyles({backgroundColor:"var(--text-error)"}),this.closeBtn&&(this.closeBtn.disabled=!1,this.closeBtn.focus())}onClose(){this.contentEl.empty()}};var k=class extends m.PluginSettingTab{constructor(t,e){super(t,e),this.plugin=e}display(){let{containerEl:t}=this;t.empty(),t.createEl("h2",{text:"Vault Embeddings Settings"}),t.createEl("h3",{text:"API Settings"}),new m.Setting(t).setName("OpenAI API Key").setDesc("API key for generating embeddings (text-embedding-3-small)").addText(i=>{i.setPlaceholder("sk-...").setValue(this.plugin.settings.openaiApiKey).onChange(async s=>{this.plugin.settings.openaiApiKey=s,await this.plugin.saveSettings()}),i.inputEl.type="password",i.inputEl.style.width="300px"}).addButton(i=>{i.setButtonText("Test").onClick(async()=>{if(!this.plugin.settings.openaiApiKey){new m.Notice("Please enter an API key first");return}i.setDisabled(!0),i.setButtonText("Testing...");try{await this.plugin.testApiKey()?new m.Notice("API key is valid!"):new m.Notice("API key is invalid")}catch(s){new m.Notice("Test failed: "+(s instanceof Error?s.message:"Unknown error"))}finally{i.setDisabled(!1),i.setButtonText("Test")}})}),t.createEl("h3",{text:"Storage Settings"}),new m.Setting(t).setName("Storage Folder").setDesc("Folder to store embedding data (will be created if not exists)").addText(i=>i.setPlaceholder("09_Embedded").setValue(this.plugin.settings.storagePath).onChange(async s=>{this.plugin.settings.storagePath=s||"09_Embedded",await this.plugin.saveSettings()})),new m.Setting(t).setName("Excluded Folders").setDesc("Folders to exclude from embedding (comma-separated)").addText(i=>i.setPlaceholder("06_Meta, Templates").setValue(this.plugin.settings.excludedFolders.join(", ")).onChange(async s=>{this.plugin.settings.excludedFolders=s.split(",").map(n=>n.trim()).filter(n=>n.length>0),await this.plugin.saveSettings()})),t.createEl("h3",{text:"Auto Embedding"}),new m.Setting(t).setName("Auto Embed").setDesc("Automatically create/update embeddings when notes are created or modified").addToggle(i=>i.setValue(this.plugin.settings.autoEmbed).onChange(async s=>{this.plugin.settings.autoEmbed=s,await this.plugin.saveSettings()})),new m.Setting(t).setName("Auto Embed Delay").setDesc("Delay before auto-embedding after modification (in seconds)").addSlider(i=>i.setLimits(1,30,1).setValue(this.plugin.settings.autoEmbedDelay/1e3).setDynamicTooltip().onChange(async s=>{this.plugin.settings.autoEmbedDelay=s*1e3,await this.plugin.saveSettings()})),t.createEl("h3",{text:"Actions"}),new m.Setting(t).setName("Embed All Notes").setDesc("Generate embeddings for all notes in the vault").addButton(i=>{i.setButtonText("Embed All").setCta().onClick(async()=>{if(!this.plugin.isConfigured()){new m.Notice("Please configure API key first");return}let s=new S(this.app,"Embedding All Notes");s.open();try{let n=await this.plugin.embedAllNotes(o=>{let a=o.completed+o.failed,l=o.completed-o.skipped,p=o.total>0?Math.round(a/o.total*100):0;s.updateProgress({current:a,total:o.total,message:`Processing: ${l} / ${a} (${o.skipped} skipped, ${o.failed} failed)`,percentage:p})});s.setComplete(`\u2705 Complete! ${n.success} embedded, ${n.skipped} skipped, ${n.failed} failed`)}catch(n){let o=n instanceof Error?n.message:"Unknown error";s.setError(`\u274C Failed: ${o}`)}})}),new m.Setting(t).setName("Update Stale Embeddings").setDesc("Only update embeddings for modified notes").addButton(i=>{i.setButtonText("Update Stale").onClick(async()=>{if(!this.plugin.isConfigured()){new m.Notice("Please configure API key first");return}let s=new S(this.app,"Updating Stale Embeddings");s.open();try{let n=await this.plugin.embedStaleNotes(o=>{let a=o.completed+o.failed,l=o.completed-o.skipped,p=o.total>0?Math.round(a/o.total*100):0;s.updateProgress({current:a,total:o.total,message:`Checking: ${l} updated / ${a} checked (${o.skipped} unchanged)`,percentage:p})});s.setComplete(`\u2705 Complete! ${n.updated} updated, ${n.skipped} skipped, ${n.failed} failed`)}catch(n){let o=n instanceof Error?n.message:"Unknown error";s.setError(`\u274C Failed: ${o}`)}})}),new m.Setting(t).setName("Clear All Embeddings").setDesc("Delete all stored embeddings").addButton(i=>{i.setButtonText("Clear All").setWarning().onClick(async()=>{if(confirm("Are you sure you want to delete all embeddings?"))try{await this.plugin.clearAllEmbeddings(),new m.Notice("All embeddings cleared")}catch(n){new m.Notice("Clear failed: "+(n instanceof Error?n.message:"Unknown error"))}})}),t.createEl("h3",{text:"Statistics"});let e=t.createDiv({cls:"vault-embeddings-stats"});this.displayStats(e)}async displayStats(t){t.empty();try{let e=await this.plugin.getStats();t.createEl("p",{text:`Total embeddings: ${e.totalEmbeddings}`}),t.createEl("p",{text:`Model: ${e.model||"Not set"}`}),t.createEl("p",{text:`Provider: ${e.provider||"Not set"}`}),t.createEl("p",{text:`Dimensions: ${e.dimensions||"Not set"}`}),t.createEl("p",{text:`Last updated: ${e.lastUpdated||"Never"}`})}catch(e){t.createEl("p",{text:"Unable to load statistics"})}}};var $=class extends d.Plugin{constructor(){super(...arguments);this.embeddingProvider=null;this.embeddingRepository=null;this.noteRepository=null;this.embeddingService=null;this.pendingAutoEmbedFiles=new Map;this.processAutoEmbedDebounced=null;this.autoEmbedProcessing=!1;this.initError=null}async onload(){console.log("Loading Vault Embeddings Plugin"),await this.loadSettings(),await this.initializeServices(),this.addCommand({id:"embed-current-note",name:"Embed current note",callback:()=>this.embedCurrentNote()}),this.addCommand({id:"embed-all-notes",name:"Embed all notes",callback:()=>this.embedAllNotesCommand()}),this.addCommand({id:"update-stale-embeddings",name:"Update stale embeddings",callback:()=>this.updateStaleCommand()}),this.addCommand({id:"show-embedding-stats",name:"Show embedding statistics",callback:()=>this.showStatsCommand()}),this.addSettingTab(new k(this.app,this)),this.registerVaultEvents(),this.addRibbonIcon("database","Vault Embeddings",()=>{this.showStatsCommand()})}async onunload(){console.log("Unloading Vault Embeddings Plugin"),this.processAutoEmbedDebounced=null,this.pendingAutoEmbedFiles.clear(),this.autoEmbedProcessing=!1,this.embeddingService=null,this.embeddingRepository=null,this.embeddingProvider=null,this.noteRepository=null}async loadSettings(){this.settings=Object.assign({},z,await this.loadData())}async saveSettings(){await this.saveData(this.settings),await this.initializeServices()}getInitError(){return this.initError}async initializeServices(){if(this.initError=null,!this.settings.openaiApiKey){console.log("Vault Embeddings: API key not configured"),this.initError="API key not configured",new d.Notice("Vault Embeddings: API key not configured. Set it in Settings \u2192 Vault Embeddings.");return}try{console.log("Vault Embeddings: Initializing provider..."),this.embeddingProvider=new w(this.settings.openaiApiKey,this.settings.model),console.log("Vault Embeddings: Provider initialized"),console.log("Vault Embeddings: Creating repository..."),this.embeddingRepository=new P(this.app,{storagePath:this.settings.storagePath}),console.log("Vault Embeddings: Initializing storage...");try{await this.embeddingRepository.initialize(),console.log("Vault Embeddings: Storage initialized")}catch(e){let i=e instanceof Error?e.message:"Unknown storage error";console.error("Vault Embeddings: Storage initialization failed:",i),this.initError=`Storage initialization failed: ${i}`,new d.Notice(`Vault Embeddings: Storage initialization failed \u2014 ${i}`);return}this.noteRepository=new x(this.app),this.embeddingService=new v(this.embeddingProvider,this.embeddingRepository,this.noteRepository),this.setupAutoEmbed(),console.log("Vault Embeddings: All services initialized successfully")}catch(e){let i=e instanceof Error?e.message:"Unknown error";console.error("Vault Embeddings: Failed to initialize services:",i),this.initError=i}}setupAutoEmbed(){this.processAutoEmbedDebounced&&(this.processAutoEmbedDebounced=null),this.pendingAutoEmbedFiles.clear(),this.settings.autoEmbed&&this.embeddingService&&(this.processAutoEmbedDebounced=(0,d.debounce)(()=>{this.processAutoEmbedQueue()},this.settings.autoEmbedDelay,!1))}async processAutoEmbedQueue(){if(!(!this.embeddingService||!this.noteRepository)){if(this.autoEmbedProcessing){this.pendingAutoEmbedFiles.size>0&&this.processAutoEmbedDebounced&&this.processAutoEmbedDebounced();return}this.autoEmbedProcessing=!0;try{let e=new Map(this.pendingAutoEmbedFiles);this.pendingAutoEmbedFiles.clear();for(let[,i]of e){let s=(0,d.normalizePath)(i.path);if(!this.settings.excludedFolders.some(o=>s.startsWith((0,d.normalizePath)(o)+"/")))try{await this.embeddingService.embedNoteByPath(i.path),console.log(`Auto-embedded: ${i.path}`)}catch(o){console.error(`Auto-embed failed for ${i.path}:`,o)}}}finally{this.autoEmbedProcessing=!1,this.pendingAutoEmbedFiles.size>0&&this.processAutoEmbedDebounced&&this.processAutoEmbedDebounced()}}}registerVaultEvents(){this.registerEvent(this.app.vault.on("modify",e=>{e instanceof d.TFile&&e.extension==="md"&&this.processAutoEmbedDebounced&&(this.pendingAutoEmbedFiles.set(e.path,e),this.processAutoEmbedDebounced())})),this.registerEvent(this.app.vault.on("create",e=>{e instanceof d.TFile&&e.extension==="md"&&this.processAutoEmbedDebounced&&(this.pendingAutoEmbedFiles.set(e.path,e),this.processAutoEmbedDebounced())})),this.registerEvent(this.app.vault.on("delete",async e=>{if(e instanceof d.TFile&&e.extension==="md"&&this.embeddingService&&this.noteRepository)try{let i=this.noteRepository.generateNoteId(e.path);await this.embeddingService.deleteEmbedding(i),console.log(`Deleted embedding: ${e.path}`)}catch(i){console.error(`Failed to delete embedding for ${e.path}:`,i)}})),this.registerEvent(this.app.vault.on("rename",async(e,i)=>{if(e instanceof d.TFile&&e.extension==="md"&&this.embeddingService&&this.noteRepository)try{let s=this.noteRepository.generateNoteId(i);await this.embeddingService.deleteEmbedding(s),this.processAutoEmbedDebounced&&(this.pendingAutoEmbedFiles.set(e.path,e),this.processAutoEmbedDebounced())}catch(s){console.error(`Failed to handle rename for ${e.path}:`,s)}}))}isConfigured(){return!!this.settings.openaiApiKey&&!!this.embeddingService}async testApiKey(){return this.embeddingProvider?this.embeddingProvider.testApiKey(this.settings.openaiApiKey):!1}async embedAllNotes(e){if(!this.embeddingService)throw new Error("Embedding service not initialized");return this.embeddingService.embedAllNotes(this.settings.excludedFolders,e)}async embedStaleNotes(e){if(!this.embeddingService)throw new Error("Embedding service not initialized");return this.embeddingService.embedStaleNotes(this.settings.excludedFolders,e)}async clearAllEmbeddings(){if(!this.embeddingService)throw new Error("Embedding service not initialized");await this.embeddingService.clearAllEmbeddings()}async getStats(){return this.embeddingService?this.embeddingService.getStats():{totalEmbeddings:0,model:this.settings.model,provider:"openai",dimensions:1536,lastUpdated:null}}async searchSimilar(e,i){return this.embeddingService?this.embeddingService.searchSimilar(e,i):[]}async findSimilarToNote(e,i){if(!this.embeddingService||!this.noteRepository)return[];let s=this.noteRepository.generateNoteId(e);return this.embeddingService.findSimilarToNote(s,i)}async embedCurrentNote(){if(!this.embeddingService||!this.noteRepository){new d.Notice("Embedding service not configured");return}let e=this.app.workspace.getActiveFile();if(!e||e.extension!=="md"){new d.Notice("No markdown file active");return}try{(await this.embeddingService.embedNoteByPath(e.path)).wasUpdated?new d.Notice(`Embedded: ${e.basename}`):new d.Notice(`Already up to date: ${e.basename}`)}catch(i){new d.Notice("Embedding failed: "+(i instanceof Error?i.message:"Unknown error"))}}async embedAllNotesCommand(){if(!this.isConfigured()){let e=this.getInitError();e?new d.Notice(`Configuration error: ${e}`):new d.Notice("Please configure API key first");return}new d.Notice("Starting embedding...");try{let e=await this.embedAllNotes(i=>{console.log(`Progress: ${i.completed}/${i.total}`)});new d.Notice(`Complete! ${e.success} embedded, ${e.skipped} skipped, ${e.failed} failed`)}catch(e){new d.Notice("Embedding failed: "+(e instanceof Error?e.message:"Unknown error"))}}async updateStaleCommand(){if(!this.isConfigured()){new d.Notice("Please configure API key first");return}new d.Notice("Updating stale embeddings...");try{let e=await this.embedStaleNotes();new d.Notice(`Complete! ${e.updated} updated, ${e.skipped} skipped, ${e.failed} failed`)}catch(e){new d.Notice("Update failed: "+(e instanceof Error?e.message:"Unknown error"))}}async showStatsCommand(){let e=await this.getStats();new d.Notice(`Embeddings: ${e.totalEmbeddings}
Model: ${e.model}
Last updated: ${e.lastUpdated||"Never"}`)}};
